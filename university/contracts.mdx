---
title: 'API Contracts'
description: 'This page contains all of our contacts for the RESTful API and Web Socket service, as well as data flow diagrams.'
icon: 'file-lines'
---

# Flow of data

![Flow of Data Diagmra](/images/university/FlowOfData.png)

# Error

Status Code: `4XX | 5XX`

```js
{
    statusCode: 4XX | 5XX,
    message: ErrorMessage
}
```

# Create Game

![Create Game Diagram](/images/university/CreateGame.png)

**Request** `POST /createGame`

```js
{
    config: GameConfigurationOptions
}
```

**Response** `200 OK`

```js
{
    gameID: GameID,
    config: GameConfigurationOptions
}
```

**Web Socket**

Once a game has been created, user will need to make a request to the websocket server that links the gameID, connectionID, host identifier and role.

```js
{
    action: "game",
    data: {
        type: "createGame",
        gameID: GameID,
        role: Host | A | B | C
    }
}
```

# Join Game

![Join Game Diagram](/images/university/JoinGame.png)

Request that the students make to join in on a game.

**Request** `POST /joinGame`
```js
{
    gameID: GameID,
    playerName: String
}
```

**Response** `200 OK`

```js
{
    gameID: GameID,
    playerData: PlayerData
}
```

**Web Socket**

If the request was successful, the client will need to make the following websocket request:
```js
{
    action: "game",
    data: {
        type: "joinGame",
        gameID: GameID,
        playerID: PlayerID,
        role: Host | A | B | C
    }
}
```

This will then linked the player ID, socket ID, player role and game ID in the connections database.

# Start Game

![Start Game Diagram](/images/university/StartGame.png)

This will be used by the game host to start a game.

**Web Socket**

The following websocket request will need to be made:

```js
{
    action: "game",
    data: {
        type: "startGame",
        gameID: GameID
    }
}
```

This will then go through the connection table, getting all of the connection ID's for the provided game ID. It will then broadcast a message out to all those clients saying that the game is about to start.

# Start of Round

The game will be managed by the host, so that means all actions will be initiated by the host. All starting round messages will be triggered by the host. The host as well as the web socket server should always remain in sync with the data, but the host is final source of data. That means the host will be the timer of the rounds, as well as triggering the respective messages.

There will need to be a timer running on the hosts client that keeps track of how long things are. We could even look at providing toast notifications about how much time is remaining, but that is a QOL for later.

The hosts client will be the initator of all the web sockets in relating to the rounds. 

**Web Socket**

A start round message will be sent to all players in the game. It will include the round number (the round that is starting), when the round is starting and the duration of the round (in seconds).

```js
{
    action: "game",
    data: {
        type: "startRound",
        round: CurrentRoundNumber,
        startTime: StartTime,
        duration: seconds
    }
}
```

# End of Round

This request will be sent when a round ends from all clients.

**Web Socket to Client**

```js
{
    action: "game",
    data: {
        type: "endRound",
        round: CurrentRoundNumber
    }
}
```

**Web Socket to Server**

The client will be notified that the round has ended and needs to send the following data back.

```js
{
    action: "game",
    data: {
        type: "roundEnd",
        round: CurrentRoundNumber,
        gameID: GameID,
        playerData: PlayerData
    }
}
```

# Process Round

Restful API route to process the previous round. Will fetch all player data from the ElasticCache, process it and then batch update the DynamoDB for the current 

**Request** `PATCH /process`

```js
{
    gameID: GameID
    round: RoundNumber
}
```

**Response** `200 OK`

```js
{
    gameID: GameID,
    round: RoundNumber,
    message: "Processed all player data."
}
```